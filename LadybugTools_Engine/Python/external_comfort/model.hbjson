from typing import List, Union
from ladybug_geometry.geometry3d import Point3D, Vector3D
from honeybee.model import Model, Room, Face, Shade
from honeybee_energy.construction.opaque import OpaqueConstruction
from honeybee_energy.material.opaque import EnergyMaterial, EnergyMaterialVegetation
from honeybee.facetype import face_types
from honeybee.boundarycondition import boundary_conditions
from honeybee_radiance.sensorgrid import SensorGrid, Sensor

_WIDTH = 10
_DEPTH = 10
_GROUND_HEIGHT = 1
_SHADE_HEIGHT = 0.2
_SHADE_HEIGHT_ABOVE_GROUND = 3

def create_ground_zone(material: Union[EnergyMaterial, EnergyMaterialVegetation], shaded: bool = False) -> Room:

    shade_id = 'SHADED' if shaded else 'UNSHADED'

    ground_zone = Room.from_box(identifier=f"GROUND_ZONE_{shade_id}", width=_WIDTH, depth=_DEPTH, height=-_GROUND_HEIGHT, origin=Point3D(-_WIDTH/2, -_DEPTH/2, 0))

    ground_top_construction = OpaqueConstruction(
        identifier=f"GROUND_CONSTRUCTION_TOP",
        materials=[material]
    )
    ground_interface_construction = OpaqueConstruction(
        identifier=f"GROUND_CONSTRUCTION_INTERFACE",
        materials=[
            EnergyMaterial(
                identifier="GROUND_MATERIAL_INTERFACE",
                roughness="Rough",
                thickness=1.0,
                conductivity=3.0,
                density=1250.0,
                specific_heat=1250.0,
                thermal_absorptance=0.9,
                solar_absorptance=0.7,
                visible_absorptance=0.7,
            )
        ]
    )

    for face in ground_zone.faces:
        face: Face
        if face.normal.z == 1:
            face.identifier = f"GROUND_ZONE_UP_{shade_id}"
            face.boundary_condition = boundary_conditions.outdoors
            face.type = face_types.roof_ceiling
            face.construction = ground_top_construction
        elif face.normal.z == -1:
            face.identifier = f"GROUND_ZONE_DOWN_{shade_id}"
            face.boundary_condition = boundary_conditions.ground
            face.type = face_types.floor
            face.construction=ground_interface_construction
        else:
            face.identifier = f"GROUND_ZONE_{face.cardinal_direction().upper()}_{shade_id}"
            face.boundary_condition = boundary_conditions.ground
            face.type = face_types.wall
            face.construction=ground_interface_construction

    return ground_zone

def create_shade_zone(material: Union[EnergyMaterial, EnergyMaterialVegetation]) -> Room:

    shade_zone = Room.from_box(identifier=f"SHADE_ZONE", width=_WIDTH, depth=_DEPTH, height=_SHADE_HEIGHT, origin=Point3D(-_WIDTH/2, -_DEPTH/2, _SHADE_HEIGHT_ABOVE_GROUND))

    shade_construction = OpaqueConstruction(
        identifier=f"SHADE_CONSTRUCTION",
        materials=[material]
    )

    for face in shade_zone.faces:
        face: Face
        face.boundary_condition = boundary_conditions.outdoors
        face.construction = shade_construction
        if face.normal.z == 1:
            face.identifier = f"SHADE_ZONE_UP"
            face.type = face_types.roof_ceiling
        elif face.normal.z == -1:
            face.identifier = f"SHADE_ZONE_DOWN"
            face.type = face_types.floor
        else:
            face.identifier = f"SHADE_ZONE_{face.cardinal_direction().upper()}"
            face.type = face_types.wall

    return shade_zone

def create_shade_valence() -> Shade:
    shades = [
        Shade.from_vertices(
            identifier=f"SHADE_VALENCE_SOUTH",
            vertices=[
                Point3D(-_WIDTH/2, -_DEPTH/2, 0),
                Point3D(-_WIDTH/2, -_DEPTH/2, 3),
                Point3D(_WIDTH/2, _DEPTH/2, 3),
                Point3D(_WIDTH/2, _DEPTH/2, 0),
            ]
        ),
        Shade.from_vertices(
            identifier=f"SHADE_VALENCE_NORTH",
            vertices=[
                Point3D(_WIDTH/2, _DEPTH/2, 0),
                Point3D(_WIDTH/2, _DEPTH/2, 3),
                Point3D(-_WIDTH/2, _DEPTH/2, 3),
                Point3D(-_WIDTH/2, _DEPTH/2, 0),
            ]
        ),
        Shade.from_vertices(
            identifier=f"SHADE_VALENCE_WEST",
            vertices=[
                Point3D(-_WIDTH/2, _DEPTH/2, 0),
                Point3D(-_WIDTH/2, _DEPTH/2, 3),
                Point3D(-_WIDTH/2, -_DEPTH/2, 3),
                Point3D(-_WIDTH/2, -_DEPTH/2, 0),
            ]
        ),
        Shade.from_vertices(
            identifier=f"SHADE_VALENCE_EAST",
            vertices=[
                Point3D(_WIDTH/2, -_DEPTH/2, 0),
                Point3D(_WIDTH/2, -_DEPTH/2, 3),
                Point3D(_WIDTH/2, _DEPTH/2, 3),
                Point3D(_WIDTH/2, _DEPTH/2, 0),
            ]
        )
    ]
    
    return shades

def create_model(ground_material: Union[EnergyMaterial, EnergyMaterialVegetation], shade_material: Union[EnergyMaterial, EnergyMaterialVegetation]) -> Model:

    displacement_vector = Vector3D(100, 100, 0)

    sensor_grid = SensorGrid(
        identifier="placeholder", 
        sensors=[
            Sensor(
                pos=Point3D(0, 0, 1.2), 
                dir=Point3D(0, 0, 1)
            ),
            Sensor(
                pos=Point3D(0, 0, 1.2), 
                dir=Point3D(0, 0, -1)
            ),
        ]
    )

    # unshaded case
    ground_zone_unshaded = create_ground_zone(ground_material, shaded=False)

    unshaded_grid = sensor_grid.copy()
    unshaded_grid.identifier = "UNSHADED"

    # shaded case
    ground_zone_shaded = create_ground_zone(ground_material, shaded=True)
    ground_zone_shaded.move(displacement_vector)

    shade_zone = create_shade_zone(shade_material)
    shade_zone.move(displacement_vector)

    shades = create_shade_valence()
    [i.move(displacement_vector) for i in shades]

    shaded_grid = sensor_grid.copy()
    shaded_grid.identifier = "SHADED"
    shaded_grid.move(displacement_vector)

    model = Model(
        identifier="EXTERNAL_COMFORT_MODEL",
        rooms=[ground_zone_unshaded, ground_zone_shaded, shade_zone],
        orphaned_shades=shades
    )

    model.properties.radiance.sensor_grids = [unshaded_grid, shaded_grid]

    return model
